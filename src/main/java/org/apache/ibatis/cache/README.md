## cache 缓存

使用委托模式，只维护一个集合，其他的委托给Cache执行

### 1. FIFO 先进先出缓存

使用 **linkedlist** 链表维护，若长度超出，则删除首部元素

### 2. LRU 最近最少使用缓存，移除最长时间不被使用的对象

使用 **LinkedHashMap** 维护，LinkedHashMap内部其实就是每次访问或者插入一个元素都会把元素放到链表末尾。那么最长时间不被使用的对象就是表头。

实现 LinkedHashMap 的 removeEldestEntry 方法，返回最老元素的 key 值。

若长度超出，返回最老元素的 key 值，检查若 key 不为空，则删除此 key 对象

### 3. Soft 软引用缓存，核心是SoftReference，移除基于垃圾回收器状态和软引用规则的对象

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。
只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。   

> SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。
也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，
SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。 

维护两个队列，一个是软引用的队列 **ReferenceQueue** ，用来保存软引用对象，他们的值可能存在也可能失效。

第二个是强引用的队列 **Deque** ， 用来保存访问过的元素（视为经常访问的元素），当容量满时删除最早入队的元素。

1. 当插入软引用到软引用缓存队列时，首先遍历删除值失效的软引用对象，然后将软引用对象插入队列。

2. 当访问软引用对象时，若已经失效，则删除元素返回null，若值未被垃圾回收，那么将软引用对象升级成为强引用对象（加入到强引用队列），同时返回其值

若强引用队列满时，删除最早插入队列的值。

### 4. Weak 弱引用缓存，可以看到代码和SoftCache如出一辙，就是SoftReference变成了WeakReference
         
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，
一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。         
         
> 更积极移除基于垃圾收集器状态和弱引用规则的对象

